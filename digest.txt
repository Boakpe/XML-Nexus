Directory structure:
└── src/
    ├── App.tsx
    ├── index.css
    ├── main.tsx
    ├── vite-env.d.ts
    ├── components/
    │   ├── GraphView.tsx
    │   ├── Tabs.tsx
    │   ├── TreeView.tsx
    │   └── XMLInput.tsx
    └── utils/
        ├── types.ts
        └── xmlParser.ts

================================================
File: App.tsx
================================================
import { useState } from 'react';
import { Github } from 'lucide-react';
import XMLInput from './components/XMLInput';
import Tabs from './components/Tabs';
import type { Tab } from './components/Tabs';
import GraphView from './components/GraphView';
import TreeView from './components/TreeView';
import { parseXML } from './utils/xmlParser';
import type { ParsedData } from './utils/types';

// A good default example for the user to start with
const defaultXML = `
<root name="My Project">
  <folder name="src">
    <file name="index.js" size="1.2KB" />
    <folder name="components">
      <file name="Button.tsx" />
      <file name="Modal.tsx" />
    </folder>
    <folder name="utils">
      <file name="api.js" />
    </folder>
  </folder>
  <folder name="public">
    <file name="index.html" />
    <file name="favicon.ico" />
  </folder>
  <file name="package.json" />
</root>
`.trim();

function App() {
  const [data, setData] = useState<ParsedData | null>(() => parseXML(defaultXML));
  const [activeTab, setActiveTab] = useState<Tab>('graph');
  const [error, setError] = useState<string | null>(null);

  const handleVisualize = (xml: string) => {
    setError(null);
    const parsed = parseXML(xml);
    if (parsed) {
      setData(parsed);
    } else {
      setData(null);
      setError("Failed to parse XML. Please check the format and try again.");
    }
  };

  return (
    <div className="flex flex-col h-screen bg-secondary font-sans">
      <header className="bg-primary text-white shadow-md p-4 flex justify-between items-center">
        <h1 className="text-2xl font-bold tracking-tight">XML Graph Visualizer</h1>
        <a 
          href="https://github.com/your-username/d3-xml-visualizer"
          target="_blank" 
          rel="noopener noreferrer" 
          className="flex items-center space-x-2 text-slate-300 hover:text-accent transition-colors"
        >
          <Github size={20} />
          <span>View on GitHub</span>
        </a>
      </header>
      
      <main className="flex-grow flex p-4 gap-4 overflow-hidden">
        <div className="w-1/3 flex flex-col">
          <XMLInput onVisualize={handleVisualize} initialValue={defaultXML} />
        </div>
        
        <div className="w-2/3 flex flex-col bg-white rounded-lg shadow-lg p-4">
          <Tabs activeTab={activeTab} setActiveTab={setActiveTab} />
          <div className="flex-grow relative border border-slate-200 rounded-md bg-slate-50 overflow-hidden">
            {error && (
              <div className="absolute inset-0 flex items-center justify-center bg-red-100 text-red-700 p-4 rounded-md">
                <p>{error}</p>
              </div>
            )}
            {!error && data && (
              <>
                <div style={{ display: activeTab === 'graph' ? 'block' : 'none', height: '100%' }}>
                  <GraphView data={data.graphData} />
                </div>
                <div style={{ display: activeTab === 'tree' ? 'block' : 'none', height: '100%' }}>
                  <TreeView data={data.treeData} />
                </div>
              </>
            )}
            {!error && !data && (
               <div className="absolute inset-0 flex items-center justify-center text-slate-500">
                <p>Enter XML data and click Visualize to begin.</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
}

export default App;


================================================
File: index.css
================================================
@import "tailwindcss";


================================================
File: main.tsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)



================================================
File: vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
File: components/GraphView.tsx
================================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import type { GraphData, D3GraphNode } from '../utils/types';

interface GraphViewProps {
  data: GraphData;
}

const legendData = [
  { type: 'root', label: 'Root Element', color: '#e74c3c' },
  { type: 'container', label: 'Container (4+ children)', color: '#3498db' },
  { type: 'element', label: 'Element', color: '#2ecc71' },
  { type: 'leaf', label: 'Leaf (no children)', color: '#f39c12' }
];

const GraphView: React.FC<GraphViewProps> = ({ data }) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const { nodes, links } = data;

  useEffect(() => {
    if (!svgRef.current || !nodes || nodes.length === 0) return;

    const parentEl = svgRef.current.parentElement!;
    const width = parentEl.clientWidth;
    const height = parentEl.clientHeight;

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height].join(' '));

    // Clear previous render
    svg.selectAll('*').remove();
    
    // Color scale for different node types
    const colorScale = d3.scaleOrdinal<string>()
      .domain(legendData.map(d => d.type))
      .range(legendData.map(d => d.color));
      
    const container = svg.append('g');

    // Simulation
    const simulation = d3.forceSimulation(nodes as d3.SimulationNodeDatum[])
      .force('link', d3.forceLink(links).id((d: any) => d.id).distance(100))
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collide', d3.forceCollide().radius(d => {
        const node = d as D3GraphNode;
        if (node.type === 'root') return 25;
        if (node.type === 'container') return 20;
        return 18;
      }));

    // Links
    const link = container.append('g')
      .attr('stroke', '#999')
      .attr('stroke-opacity', 0.6)
      .selectAll('line')
      .data(links)
      .join('line')
      .attr('stroke-width', 1.5);

    // Drag behavior
    const drag = (simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>) => {
      function dragstarted(event: d3.D3DragEvent<any, any, any>, d: any) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event: d3.D3DragEvent<any, any, any>, d: any) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event: d3.D3DragEvent<any, any, any>, d: any) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
      return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
    }

    // Nodes
    const node = container.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .join('g')
      .call(drag(simulation) as any);

    // Add circles to nodes
    node.append('circle')
      .attr('r', d => {
        if (d.type === 'root') return 20;
        if (d.type === 'container') return 15;
        if (d.type === 'leaf') return 10;
        return 12;
      })
      .attr('fill', d => colorScale(d.type))
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    // Add labels to nodes
    const text = node.append('text')
      .attr('font-size', '9px')
      .attr('font-family', 'sans-serif')
      .attr('text-anchor', 'middle')
      .attr('fill', '#333')
      .style('pointer-events', 'none');
      
    text.each(function (d) {
      const lines = d.label.split('\n');
      const textNode = d3.select(this);
      const lineHeight = 1.2; // ems
      const startY = `-${(lines.length - 1) / 2 * lineHeight}em`;
      
      lines.forEach((line, i) => {
        textNode.append('tspan')
          .attr('x', 0)
          .attr('dy', i === 0 ? startY : `${lineHeight}em`)
          .text(line);
      });
    });

    // Zoom behavior
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 8])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });
    svg.call(zoom);

    // Add legend (not affected by zoom)
    const legend = svg.append('g')
      .attr('class', 'legend')
      .attr('transform', 'translate(20, 20)');

    const legendItem = legend.selectAll('.legend-item')
      .data(legendData)
      .join('g')
      .attr('class', 'legend-item')
      .attr('transform', (d, i) => `translate(0, ${i * 25})`);

    legendItem.append('circle')
      .attr('r', 8)
      .attr('fill', d => d.color);

    legendItem.append('text')
      .attr('x', 15)
      .attr('y', 0)
      .attr('dy', '.35em')
      .attr('font-size', '12px')
      .attr('font-family', 'sans-serif')
      .text(d => d.label);

    // Tick function
    simulation.on('tick', () => {
      link
        .attr('x1', d => (d.source as D3GraphNode).x!)
        .attr('y1', d => (d.source as D3GraphNode).y!)
        .attr('x2', d => (d.target as D3GraphNode).x!)
        .attr('y2', d => (d.target as D3GraphNode).y!);

      node
        .attr('transform', d => `translate(${d.x!}, ${d.y!})`);
    });

    return () => {
      simulation.stop();
    };
  }, [nodes, links]);

  return <svg ref={svgRef} className="w-full h-full cursor-grab"></svg>;
};

export default GraphView;


================================================
File: components/Tabs.tsx
================================================
import React from 'react';
import clsx from 'clsx';
import { GitBranch, Share2 } from 'lucide-react';

export type Tab = 'graph' | 'tree';

interface TabsProps {
  activeTab: Tab;
  setActiveTab: (tab: Tab) => void;
}

const tabsConfig: { id: Tab; label: string; icon: React.ElementType }[] = [
  { id: 'graph', label: 'Force Graph', icon: Share2 },
  { id: 'tree', label: 'Tidy Tree', icon: GitBranch },
];

const Tabs: React.FC<TabsProps> = ({ activeTab, setActiveTab }) => {
  return (
    <div className="flex space-x-1 rounded-lg bg-slate-200 p-1 mb-4">
      {tabsConfig.map((tab) => {
        const Icon = tab.icon;
        return (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={clsx(
              'w-full flex items-center justify-center rounded-md py-2.5 text-sm font-medium leading-5 transition-all duration-300',
              'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-slate-200 ring-white',
              {
                'bg-white text-accent shadow': activeTab === tab.id,
                'text-primary hover:bg-white/[0.6] hover:text-accent': activeTab !== tab.id,
              }
            )}
          >
            <Icon className="w-5 h-5 mr-2" />
            {tab.label}
          </button>
        );
      })}
    </div>
  );
};

export default Tabs;


================================================
File: components/TreeView.tsx
================================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import type { D3TreeNode } from '../utils/types';

interface TreeViewProps {
  data: D3TreeNode;
}

const TreeView: React.FC<TreeViewProps> = ({ data }) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const rootRef = useRef<d3.HierarchyNode<D3TreeNode> | null>(null);

  useEffect(() => {
    if (!svgRef.current || !data) return;

    const parentEl = svgRef.current.parentElement!;
    const width = parentEl.clientWidth || 800;
    const height = parentEl.clientHeight || 600;

    const dx = 25; // Vertical separation
    const dy = width / 4; // Horizontal separation

    const tree = d3.tree<D3TreeNode>().nodeSize([dx, dy]);
    const root = d3.hierarchy(data);
    rootRef.current = root;

    root.x0 = height / 2;
    root.y0 = 0;

    // Assign unique IDs and collapse nodes after the first level for initial view
    let i = 0;
    root.descendants().forEach(d => {
      d.id = ++i;
      // @ts-ignore - attaching _children for collapse/expand
      d._children = d.children;
      if (d.depth > 1) {
        d.children = null;
      }
    });

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [-dy / 3, -height / 2, width, height].join(' '))
      .style('font', '12px sans-serif');

    // Clear previous render
    svg.selectAll('*').remove();

    const gLink = svg.append('g')
      .attr('fill', 'none')
      .attr('stroke', '#94a3b8')
      .attr('stroke-opacity', 0.6)
      .attr('stroke-width', 1.5);

    const gNode = svg.append('g')
      .attr('cursor', 'pointer')
      .attr('pointer-events', 'all');

    // Tooltip setup
    const tooltip = d3.select('body').append('div')
      .attr('class', 'absolute p-2 text-sm bg-slate-800 text-white rounded-md opacity-0 pointer-events-none transition-opacity')
      .style('transform', 'translate(15px, -15px)');

    function update(source: d3.HierarchyNode<D3TreeNode>) {
      const duration = (d3.event && d3.event.altKey) ? 2500 : 250;
      const nodes = root.descendants().reverse();
      const links = root.links();

      // Compute the new tree layout.
      tree(root);

      let left = root;
      let right = root;
      root.eachBefore(node => {
        if (node.x < left.x!) left = node;
        if (node.x > right.x!) right = node;
      });

      const transition = svg.transition()
        .duration(duration)
        .attr('viewBox', [-dy / 3, left.x! - dx, width, height].join(' '))
        .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

      // Update the nodesâ€¦
      const node = gNode.selectAll('g')
        .data(nodes, d => (d as any).id);

      // Enter any new nodes at the parent's previous position.
      const nodeEnter = node.enter().append('g')
        .attr('transform', d => `translate(${(source as any).y0},${(source as any).x0})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0)
        .on('click', (event, d) => {
          d.children = d.children ? null : (d as any)._children;
          update(d);
        })
        .on('mouseover', (event, d) => {
          tooltip.transition().duration(200).style('opacity', .9);
          const attrs = Object.entries(d.data.attributes)
            .map(([k,v]) => `<li><strong>${k}:</strong> ${v}</li>`)
            .join('');
          tooltip.html(`
            <div class="font-bold text-base">${d.data.name}</div>
            ${attrs.length > 0 ? `<ul class="list-disc list-inside mt-1">${attrs}</ul>` : ''}
          `);
        })
        .on('mousemove', (event) => {
          tooltip.style('left', (event.pageX) + 'px').style('top', (event.pageY) + 'px');
        })
        .on('mouseout', () => {
          tooltip.transition().duration(500).style('opacity', 0);
        });

      nodeEnter.append('circle')
        .attr('r', 6)
        .attr('stroke-width', 10)
        .attr('fill', d => (d as any)._children ? '#0f172a' : '#38bdf8') // Dark for expandable, blue for leaf
        .attr('stroke', d => (d as any)._children ? '#0f172a' : '#38bdf8');

      nodeEnter.append('text')
        .attr('dy', '0.31em')
        .attr('x', d => d.children || (d as any)._children ? -12 : 12)
        .attr('text-anchor', d => d.children || (d as any)._children ? 'end' : 'start')
        .text(d => d.data.name)
        .clone(true).lower()
        .attr('stroke-linejoin', 'round')
        .attr('stroke-width', 3)
        .attr('stroke', 'white');

      // Transition nodes to their new position.
      const nodeUpdate = node.merge(nodeEnter).transition(transition)
        .attr('transform', d => `translate(${d.y},${d.x})`)
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1);
      
      nodeUpdate.select('circle')
        .attr('fill', d => (d as any)._children ? '#0f172a' : '#38bdf8')
        .attr('stroke', d => (d as any)._children ? '#0f172a' : '#38bdf8');


      // Transition exiting nodes to the parent's new position.
      const nodeExit = node.exit().transition(transition).remove()
        .attr('transform', d => `translate(${source.y},${source.x})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0);

      // Update the linksâ€¦
      const link = gLink.selectAll('path')
        .data(links, d => (d.target as any).id);

      // Enter any new links at the parent's previous position.
      const linkEnter = link.enter().append('path')
        .attr('d', d => {
          const o = { x: (source as any).x0, y: (source as any).y0 };
          return d3.linkHorizontal()({ source: o, target: o } as any);
        });

      // Transition links to their new position.
      link.merge(linkEnter).transition(transition)
        .attr('d', d3.linkHorizontal<any, d3.HierarchyPointNode<D3TreeNode>>()
          .x(d => d.y)
          .y(d => d.x));

      // Transition exiting nodes to the parent's new position.
      link.exit().transition(transition).remove()
        .attr('d', d => {
          const o = { x: source.x!, y: source.y! };
          return d3.linkHorizontal()({ source: o, target: o } as any);
        });

      // Stash the old positions for transition.
      root.eachBefore(d => {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    update(root);

    // Zoom setup
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 3])
      .on('zoom', (event) => {
        gNode.attr('transform', event.transform);
        gLink.attr('transform', event.transform);
      });
    
    // @ts-ignore - d3 types for zoom are a bit tricky
    svg.call(zoom).call(zoom.translateTo, root.y0, root.x0);

    return () => {
      // Cleanup tooltip on component unmount
      tooltip.remove();
    };
  }, [data]);

  return <svg ref={svgRef} className="w-full h-full cursor-grab" />;
};

export default TreeView;


================================================
File: components/XMLInput.tsx
================================================
import React, { useState, useRef, useEffect } from "react";
import { HardDriveUpload } from "lucide-react";

// CodeMirror imports
import { EditorView, basicSetup } from "codemirror";
import { xml as xmlLang } from "@codemirror/lang-xml";

interface XMLInputProps {
  onVisualize: (xml: string) => void;
  initialValue: string;
}

const XMLInput: React.FC<XMLInputProps> = ({ onVisualize, initialValue }) => {
  // This state will hold the editor's content. It's kept in sync by the editor's listener.
  const [xml, setXml] = useState(initialValue);
  const editorRef = useRef<HTMLDivElement>(null);
  const editorViewRef = useRef<EditorView | null>(null);

  // --- EFFECT 1: Create the editor instance (runs only once) ---
  useEffect(() => {
    if (editorRef.current && !editorViewRef.current) {
      const view = new EditorView({
        doc: initialValue, // Use initialValue for the very first creation
        extensions: [
          basicSetup,
          xmlLang(),
          EditorView.updateListener.of((update) => {
            if (update.docChanged) {
              // When the user types, update the React state
              const newValue = update.state.doc.toString();
              setXml(newValue);
            }
          }),
          EditorView.theme({
            "&": {
              height: "100%",
            },
            ".cm-scroller": {
              fontFamily: "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace",
              fontSize: "14px",
            },
            ".cm-focused": {
              outline: "2px solid rgb(14 165 233)",
              outlineOffset: "2px",
            },
          }),
        ],
        parent: editorRef.current,
      });

      editorViewRef.current = view;
    }

    // Cleanup function to destroy the editor when the component unmounts
    return () => {
      if (editorViewRef.current) {
        editorViewRef.current.destroy();
        editorViewRef.current = null;
      }
    };
    // The empty dependency array [] ensures this effect runs ONLY ONCE on mount.
  }, []); 

  // --- EFFECT 2: Sync external changes (from props) to the editor ---
  useEffect(() => {
    // Check if the editor instance exists and if the prop value is different from the editor's current content
    if (editorViewRef.current && initialValue !== editorViewRef.current.state.doc.toString()) {
      // If they are different, dispatch a transaction to update the editor's content
      editorViewRef.current.dispatch({
        changes: {
          from: 0,
          to: editorViewRef.current.state.doc.length,
          insert: initialValue,
        },
      });
    }
    // This effect runs whenever the `initialValue` prop changes.
  }, [initialValue]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onVisualize(xml);
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="flex flex-col h-full bg-white rounded-lg shadow-lg p-6"
    >
      <h2 className="text-2xl font-bold text-primary mb-4">XML Data</h2>
      <div
        ref={editorRef}
        className="flex-grow w-full border border-slate-300 rounded-md overflow-hidden bg-slate-50"
        style={{ minHeight: "300px" }}
      />
      <button
        type="submit"
        className="mt-4 w-full flex items-center justify-center bg-accent text-white font-bold py-3 px-4 rounded-md hover:bg-sky-500 bg-sky-800 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-accent"
      >
        <HardDriveUpload className="mr-2 h-5 w-5" />
        Visualize
      </button>
    </form>
  );
};

export default XMLInput;


================================================
File: utils/types.ts
================================================
// For the Tree Layout (hierarchical)
export interface D3TreeNode {
  name: string;
  attributes: { [key: string]: string };
  children?: D3TreeNode[];
}

// For the Force-Directed Graph (flat)
export interface D3GraphNode extends d3.SimulationNodeDatum {
  id: string;
  label: string; // Combined display text (tag, attributes, content)
  tagName: string; // Original XML tag name
  type: 'root' | 'container' | 'element' | 'leaf';
  level: number;
  attributes: { [key: string]: string };
}

export interface D3GraphLink extends d3.SimulationLinkDatum<D3GraphNode> {
  source: string;
  target: string;
}

export interface GraphData {
  nodes: D3GraphNode[];
  links: D3GraphLink[];
}

// Combined result from the parser
export interface ParsedData {
  treeData: D3TreeNode;
  graphData: GraphData;
}


================================================
File: utils/xmlParser.ts
================================================
import type { D3TreeNode, GraphData, D3GraphNode, D3GraphLink, ParsedData } from './types';

// Helper to extract attributes from an XML element
const getAttributes = (element: Element): { [key: string]: string } => {
  const attrs: { [key: string]: string } = {};
  for (let i = 0; i < element.attributes.length; i++) {
    const attr = element.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
};

export const parseXML = (xmlString: string): ParsedData | null => {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "application/xml");

    // Check for parsing errors
    if (xmlDoc.getElementsByTagName("parsererror").length) {
      console.error("Error parsing XML");
      throw new Error("Invalid XML format");
    }

    const rootElement = xmlDoc.documentElement;
    if (!rootElement) return null;

    let nodeIdCounter = 0;
    const nodes: D3GraphNode[] = [];
    const links: D3GraphLink[] = [];

    const traverse = (element: Element, parentId: string | null, level: number): D3TreeNode => {
      const currentId = `node-${nodeIdCounter++}`;
      
      const nodeAttributes = getAttributes(element);
      const childElements = Array.from(element.children);

      // Determine node type based on element characteristics
      let nodeType: D3GraphNode['type'] = 'element';
      if (level === 0) nodeType = 'root';
      else if (childElements.length === 0) nodeType = 'leaf';
      else if (childElements.length > 3) nodeType = 'container';

      // Create node label
      let label = element.tagName;
      const attributeStrings = Object.entries(nodeAttributes).map(([k, v]) => `${k}="${v}"`);
      if (attributeStrings.length > 0) {
        label += `\n[${attributeStrings.join(', ')}]`;
      }
      
      const textContent = Array.from(element.childNodes)
        .filter(child => child.nodeType === Node.TEXT_NODE)
        .map(child => child.textContent?.trim())
        .filter(text => text && text.length > 0)
        .join(' ');
        
      if (textContent && childElements.length === 0) {
        const truncatedText = textContent.length > 50 
          ? textContent.substring(0, 47) + '...' 
          : textContent;
        label += `\n"${truncatedText}"`;
      }
      
      // For flat graph data
      const graphNode: D3GraphNode = {
        id: currentId,
        label: label,
        tagName: element.tagName,
        type: nodeType,
        level: level,
        attributes: nodeAttributes,
      };
      nodes.push(graphNode);

      if (parentId) {
        links.push({ source: parentId, target: currentId });
      }

      // For hierarchical tree data
      const treeNode: D3TreeNode = {
        name: element.tagName,
        attributes: nodeAttributes,
        children: childElements.map(child => traverse(child, currentId, level + 1)),
      };

      // If there are no element children, add text content as a child for the tree view
      if (textContent && childElements.length === 0) {
        treeNode.children?.push({ name: `"${textContent}"`, attributes: {}, children: [] });
      }

      return treeNode;
    };

    const treeData = traverse(rootElement, null, 0);
    const graphData: GraphData = { nodes, links };

    return { treeData, graphData };

  } catch (error) {
    console.error("XML parsing failed:", error);
    return null;
  }
};

